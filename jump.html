<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Jump Jump · Platform Game</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #0f172a;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }
    .wrap {
      height: 100%;
      display: grid;
      place-items: center;
    }
    canvas {
      background: linear-gradient(#e2e8f0, #f8fafc 50%, #e2e8f0);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0,0,0,.25);
      touch-action: none;
    }
    .hud {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #e2e8f0;
      display: flex;
      gap: 16px;
      align-items: center;
      font-weight: 600;
    }
    .btn {
      padding: 8px 12px;
      border-radius: 10px;
      background: #22c55e;
      color: #0f172a;
      border: none;
      cursor: pointer;
      font-weight: 700;
      box-shadow: 0 6px 20px rgba(34,197,94,.4);
    }
    .btn:hover {
      filter: brightness(1.05);
    }
    .toast {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      color: #94a3b8;
      font-size: 14px;
      text-align: center;
      max-width: 400px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="420" height="720" aria-label="Jump a Jump Game"></canvas>
  </div>
  <div class="hud">
    <div>Score: <span id="score">0</span></div>
    <button id="restart" class="btn" title="Restart Game">Restart</button>
  </div>
  <div class="toast">Hold (or long press on touch) to charge power, release to jump. After landing on the next platform, it will scroll left and generate a new platform.</div>

  <script>
  (() => {
    'use strict';

    // ===== DOM Elements =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const restartBtn = document.getElementById('restart');

    // ===== Game Constants =====
    const CANVAS = {
      WIDTH: canvas.width,
      HEIGHT: canvas.height
    };

    const PHYSICS = {
      GRAVITY: 2500,           // px/s²
      MAX_JUMP_SPEED: 1300,    // px/s
      JUMP_ANGLE: -Math.PI/3,  // ~-60° (right-up direction)
      CHARGE_COEFFICIENT: 0.015,
      CHARGE_GAMMA: 0.65,      // Non-linear charge power
    };

    const WORLD = {
      GROUND_Y: CANVAS.HEIGHT - 120,
      PLATFORM_Y: CANVAS.HEIGHT - 180,
      SCROLL_SPEED: 600,       // px/s for platform alignment
    };

    const PLATFORM_CONFIG = {
      ANCHOR_X: 130,           // Left platform fixed position
      BASE_WIDTH: 110,
      BASE_HEIGHT: 22,
      MIN_WIDTH: 80,
      MAX_WIDTH: 200,
      MIN_GAP: 140,
      MAX_GAP: 340,
    };

    const PLAYER_CONFIG = {
      RADIUS: 18,
      INITIAL_X: PLATFORM_CONFIG.ANCHOR_X,
      INITIAL_Y: WORLD.PLATFORM_Y - 18,
      // Visual squash/stretch parameters
      CHARGE_SCALE_FACTOR: 0.22,
      MIN_SCALE_Y: 0.64,
      SCALE_BETA: 0.7,
      // Spring animation for bounce
      SPRING_OMEGA: 14,
      SPRING_ZETA: 0.28,
    };

    // ===== Game State =====
    const gameState = {
      score: 0,
      lastFrameTime: performance.now(),
    };

    // ===== Player Object =====
    const player = {
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      scaleX: 1,
      scaleY: 1,
      state: 'idle', // 'idle' | 'charging' | 'jumping' | 'scrolling' | 'dead'
      chargeTime: 0,
      spring: {
        active: false,
        time: 0,
        amplitude: 0,
      },

      reset() {
        this.x = PLAYER_CONFIG.INITIAL_X;
        this.y = PLAYER_CONFIG.INITIAL_Y;
        this.vx = 0;
        this.vy = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.state = 'idle';
        this.chargeTime = 0;
        this.spring.active = false;
        this.spring.time = 0;
      },

      startCharging() {
        if (this.state !== 'idle') return;
        this.state = 'charging';
        this.chargeTime = 0;
      },

      releaseJump() {
        if (this.state !== 'charging') return;

        // Calculate jump speed based on charge time
        const rawSpeed = PHYSICS.CHARGE_COEFFICIENT *
                        Math.pow(this.chargeTime * 1000, PHYSICS.CHARGE_GAMMA) * 1000;
        const speed = Math.min(PHYSICS.MAX_JUMP_SPEED, rawSpeed);

        // Set velocity components
        this.vx = Math.cos(PHYSICS.JUMP_ANGLE) * speed;
        this.vy = Math.sin(PHYSICS.JUMP_ANGLE) * speed;
        this.state = 'jumping';

        // Activate spring bounce animation
        this.spring.active = true;
        this.spring.time = 0;
        this.spring.amplitude = (1 - this.scaleY) * 0.95;
      },

      updateCharging(dt) {
        this.chargeTime += dt;

        // Calculate squash effect
        const t = this.chargeTime;
        const scaleY = Math.max(
          1 - PLAYER_CONFIG.CHARGE_SCALE_FACTOR * Math.pow(t, PHYSICS.CHARGE_GAMMA),
          PLAYER_CONFIG.MIN_SCALE_Y
        );
        const scaleX = Math.pow(1 / scaleY, PLAYER_CONFIG.SCALE_BETA);

        this.scaleY = scaleY;
        this.scaleX = scaleX;
      },

      updateJumping(dt) {
        // Apply gravity
        this.vy += PHYSICS.GRAVITY * dt;

        // Update position
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        // Air stretch effect
        const stretchFactor = 1 + clamp(-this.vy / 3000, -0.12, 0.12);
        const airScaleX = stretchFactor;
        const airScaleY = 1 / stretchFactor;

        // Spring bounce animation
        if (this.spring.active) {
          this.spring.time += dt;
          const { time, amplitude } = this.spring;
          const w = PLAYER_CONFIG.SPRING_OMEGA;
          const z = PLAYER_CONFIG.SPRING_ZETA;
          const wd = w * Math.sqrt(1 - z * z);

          const rebound = 1 + amplitude * Math.exp(-z * w * time) * Math.cos(wd * time);
          this.scaleY = rebound * airScaleY;
          this.scaleX = Math.pow(1 / rebound, PLAYER_CONFIG.SCALE_BETA) * airScaleX;

          if (time > 0.85) {
            this.spring.active = false;
            this.scaleX = airScaleX;
            this.scaleY = airScaleY;
          }
        } else {
          this.scaleX = airScaleX;
          this.scaleY = airScaleY;
        }
      },
    };

    // ===== Platform Management =====
    const platformManager = {
      platforms: [],
      scrollOffset: 0,

      reset() {
        this.platforms = [];
        this.scrollOffset = 0;

        // Create initial left platform
        this.platforms.push(this.createPlatform(
          PLATFORM_CONFIG.ANCHOR_X,
          PLATFORM_CONFIG.BASE_WIDTH
        ));

        // Create initial right platform (visible on screen)
        const gap = this.randomGap();
        const rightX = PLATFORM_CONFIG.ANCHOR_X + gap;
        this.platforms.push(this.createPlatform(
          rightX,
          this.randomWidth()
        ));
      },

      createPlatform(centerX, width) {
        return {
          centerX: centerX,  // Store center position for easier calculations
          y: WORLD.PLATFORM_Y,
          width: width,
          height: PLATFORM_CONFIG.BASE_HEIGHT,

          // Computed properties
          get left() { return this.centerX - this.width / 2; },
          get right() { return this.centerX + this.width / 2; },
          get top() { return this.y - this.height; },
        };
      },

      randomWidth() {
        return PLATFORM_CONFIG.MIN_WIDTH +
               Math.random() * (PLATFORM_CONFIG.MAX_WIDTH - PLATFORM_CONFIG.MIN_WIDTH);
      },

      randomGap() {
        return PLATFORM_CONFIG.MIN_GAP +
               Math.random() * (PLATFORM_CONFIG.MAX_GAP - PLATFORM_CONFIG.MIN_GAP);
      },

      getCurrentPlatform() {
        return this.platforms[0];
      },

      getTargetPlatform() {
        return this.platforms[1];
      },

      scrollToAlign(dt) {
        const target = this.getTargetPlatform();
        const targetCenterX = PLATFORM_CONFIG.ANCHOR_X;

        if (target.centerX > targetCenterX) {
          const distance = WORLD.SCROLL_SPEED * dt;
          const actualMove = Math.min(distance, target.centerX - targetCenterX);

          // Move all platforms and player
          this.platforms.forEach(p => p.centerX -= actualMove);
          player.x -= actualMove;

          return false; // Still scrolling
        } else {
          // Alignment complete - snap to exact position
          const snapDelta = targetCenterX - target.centerX;
          this.platforms.forEach(p => p.centerX += snapDelta);
          player.x += snapDelta;

          // Remove old platform and generate new one
          this.platforms.shift();
          const gap = this.randomGap();
          const newCenterX = PLATFORM_CONFIG.ANCHOR_X + gap;
          this.platforms.push(this.createPlatform(newCenterX, this.randomWidth()));

          return true; // Alignment finished
        }
      },

      checkLanding() {
        const target = this.getTargetPlatform();
        const playerBottom = player.y;
        const platformTop = target.top;

        // Check if player is falling and crosses platform top
        if (player.vy > 0 && playerBottom >= platformTop) {
          // Check horizontal position
          if (player.x >= target.left && player.x <= target.right) {
            // Successful landing
            player.y = platformTop;
            player.vx = 0;
            player.vy = 0;
            player.scaleX = 1;
            player.scaleY = 1;
            return true;
          }
        }
        return false;
      },

      checkFailure() {
        const target = this.getTargetPlatform();
        // Fall below screen or significantly below target platform
        return player.y > CANVAS.HEIGHT + 80 ||
               (player.vy > 0 && player.y > target.y + 80);
      },
    };

    // ===== Utility Functions =====
    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    // ===== Game Loop =====
    function update(dt) {
      switch (player.state) {
        case 'charging':
          player.updateCharging(dt);
          break;

        case 'jumping':
          player.updateJumping(dt);

          // Check for successful landing
          if (platformManager.checkLanding()) {
            gameState.score++;
            scoreEl.textContent = gameState.score;
            player.state = 'scrolling';
          }
          // Check for failure
          else if (platformManager.checkFailure()) {
            player.state = 'dead';
          }
          break;

        case 'scrolling':
          const alignmentComplete = platformManager.scrollToAlign(dt);
          if (alignmentComplete) {
            player.state = 'idle';
          }
          break;
      }
    }

    function render() {
      ctx.clearRect(0, 0, CANVAS.WIDTH, CANVAS.HEIGHT);

      // Render layers
      renderSky();
      renderGround();
      renderPlatforms();
      renderPlayer();

      // Render game over overlay
      if (player.state === 'dead') {
        renderGameOver();
      }
    }

    function renderSky() {
      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = '#0ea5e9';

      const time = Date.now() / 30;
      for (let i = 0; i < 6; i++) {
        const y = 80 + i * 60;
        const x = (i * 80 + time) % CANVAS.WIDTH;
        ctx.beginPath();
        ctx.arc(x, y, 40, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function renderGround() {
      // Ground surface
      ctx.fillStyle = '#cbd5e1';
      ctx.fillRect(0, WORLD.GROUND_Y, CANVAS.WIDTH, CANVAS.HEIGHT - WORLD.GROUND_Y);

      // Platform shadows
      ctx.fillStyle = 'rgba(0,0,0,.05)';
      platformManager.platforms.forEach(p => {
        const radius = p.width * 0.45;
        ctx.beginPath();
        ctx.ellipse(p.centerX, p.y + p.height + 6, radius, radius * 0.35, 0, 0, Math.PI * 2);
        ctx.fill();
      });

      // Player shadow
      ctx.beginPath();
      ctx.ellipse(player.x, WORLD.PLATFORM_Y + 20, 22, 8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    function renderPlatforms() {
      platformManager.platforms.forEach((platform, index) => {
        const color = index === 0 ? '#64748b' : '#60a5fa';
        renderPlatform(platform, color);
      });
    }

    function renderPlatform(platform, color) {
      ctx.save();

      // Main platform body
      ctx.fillStyle = color;
      roundRect(platform.left, platform.top, platform.width, platform.height, 10);
      ctx.fill();

      // Top highlight
      ctx.fillStyle = 'rgba(255,255,255,.25)';
      roundRect(platform.left + 4, platform.top + 4, platform.width - 8, 6, 6);
      ctx.fill();

      ctx.restore();
    }

    function renderPlayer() {
      ctx.save();
      ctx.translate(player.x, player.y);
      ctx.scale(player.scaleX, player.scaleY);
      ctx.translate(0, -28); // Offset to foot anchor point

      // Body
      ctx.fillStyle = '#111827';
      roundRect(-16, -36, 32, 64, 12);
      ctx.fill();

      // Eyes
      ctx.fillStyle = '#f1f5f9';
      circle(-5, -12, 3);
      ctx.fill();
      circle(5, -12, 3);
      ctx.fill();

      ctx.restore();
    }

    function renderGameOver() {
      ctx.fillStyle = 'rgba(15,23,42,.75)';
      ctx.fillRect(0, 0, CANVAS.WIDTH, CANVAS.HEIGHT);

      ctx.fillStyle = '#e2e8f0';
      ctx.font = '700 28px ui-sans-serif, system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Game Over', CANVAS.WIDTH / 2, CANVAS.HEIGHT / 2 - 10);

      ctx.font = '600 16px ui-sans-serif, system-ui';
      ctx.fillText('Click Restart to play again', CANVAS.WIDTH / 2, CANVAS.HEIGHT / 2 + 22);
    }

    // ===== Drawing Utilities =====
    function roundRect(x, y, width, height, radius) {
      const r = Math.min(radius, width / 2, height / 2);
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + width, y, x + width, y + height, r);
      ctx.arcTo(x + width, y + height, x, y + height, r);
      ctx.arcTo(x, y + height, x, y, r);
      ctx.arcTo(x, y, x + width, y, r);
      ctx.closePath();
    }

    function circle(x, y, radius) {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
    }

    // ===== Input Handling =====
    function handlePointerDown(e) {
      if (player.state === 'idle') {
        player.startCharging();
      }
    }

    function handlePointerUp(e) {
      if (player.state === 'charging') {
        player.releaseJump();
      }
    }

    canvas.addEventListener('pointerdown', handlePointerDown);
    canvas.addEventListener('pointerup', handlePointerUp);
    canvas.addEventListener('pointercancel', handlePointerUp);
    canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });

    // ===== Game Control =====
    function resetGame() {
      gameState.score = 0;
      scoreEl.textContent = gameState.score;
      player.reset();
      platformManager.reset();
    }

    restartBtn.addEventListener('click', resetGame);

    // ===== Main Loop =====
    function gameLoop(currentTime) {
      const dt = Math.min(0.033, (currentTime - gameState.lastFrameTime) / 1000);
      gameState.lastFrameTime = currentTime;

      if (player.state !== 'dead') {
        update(dt);
      }
      render();

      requestAnimationFrame(gameLoop);
    }

    // ===== Start Game =====
    resetGame();
    requestAnimationFrame(gameLoop);
  })();
  </script>
</body>
</html>